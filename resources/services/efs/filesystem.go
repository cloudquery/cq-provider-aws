// Code generated by internal/generators/main.go; DO NOT EDIT.

package efs

import (
	"context"
	"encoding/json"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/cloudcontrol"
	"github.com/cloudquery/cq-provider-aws/client"
	"github.com/cloudquery/cq-provider-sdk/provider/diag"
	"github.com/cloudquery/cq-provider-sdk/provider/schema"
	"golang.org/x/sync/errgroup"
)

func Aws_efs_filesystem() *schema.Table {
  return &schema.Table{
    Name: "cloudcontrol_aws_efs_filesystem",
    Description: "aws_efs_filesystem",
    Resolver: fetchaws_efs_filesystem,
    Multiplex: client.ServiceAccountRegionMultiplexer(""),
    DeleteFilter: client.DeleteAccountRegionFilter,
    Columns: []schema.Column {
    	{
				Name: "account_id",
				Type: schema.TypeString,
			},
      {
				Name: "region",
				Type: schema.TypeString,
			},
      
      {
        Name: "PerformanceMode",
        Description: ``,
        Type: schema.TypeString,
      },
      {
        Name: "ProvisionedThroughputInMibps",
        Description: ``,
        Type: schema.TypeFloat,
      },
      {
        Name: "ThroughputMode",
        Description: ``,
        Type: schema.TypeString,
      },
      {
        Name: "BypassPolicyLockoutSafetyCheck",
        Description: `Whether to bypass the FileSystemPolicy lockout safety check. The policy lockout safety check determines whether the policy in the request will prevent the principal making the request to be locked out from making future PutFileSystemPolicy requests on the file system. Set BypassPolicyLockoutSafetyCheck to True only when you intend to prevent the principal that is making the request from making a subsequent PutFileSystemPolicy request on the file system. Defaults to false`,
        Type: schema.TypeBool,
      },
      {
        Name: "Arn",
        Description: ``,
        Type: schema.TypeString,
      },
      {
        Name: "FileSystemTags",
        Description: ``,
        Type: schema.TypeJSON,
      },
      {
        Name: "LifecyclePolicies",
        Description: ``,
        Type: schema.TypeJSON,
      },
      {
        Name: "FileSystemPolicy",
        Description: ``,
        Type: schema.TypeJSON,
      },
      {
        Name: "BackupPolicy",
        Description: ``,
        Type: schema.TypeJSON,
      },
      {
        Name: "AvailabilityZoneName",
        Description: ``,
        Type: schema.TypeString,
      },
      {
        Name: "FileSystemId",
        Description: ``,
        Type: schema.TypeString,
      },
      {
        Name: "Encrypted",
        Description: ``,
        Type: schema.TypeBool,
      },
      {
        Name: "KmsKeyId",
        Description: ``,
        Type: schema.TypeString,
      },
    },
  }
}


func fetchaws_efs_filesystem(ctx context.Context, meta schema.ClientMeta, parent *schema.Resource, res chan<- interface{}) error {
  config := cloudcontrol.ListResourcesInput{
		TypeName:   aws.String("AWS::EFS::FileSystem"),
		MaxResults: aws.Int32(100),
	}
	c := meta.(*client.Client)
  svc := cloudcontrol.NewFromConfig(c.AWSCfg.Copy(), func(o *cloudcontrol.Options) {
		o.Region = c.Region
	})
	for {
		listResources, err := svc.ListResources(ctx, &config)
		if err != nil {
			return diag.WrapError(err)
		}
		// batchResults := make([]map[string]interface{}, len(listResources.ResourceDescriptions))
		errGroup, ctx := errgroup.WithContext(ctx)
		for _, item := range listResources.ResourceDescriptions {
			// i := i
			it := item
			errGroup.Go(func() error {
				r, err := svc.GetResource(ctx, &cloudcontrol.GetResourceInput{
					Identifier: it.Identifier,
					TypeName:   aws.String("AWS::EFS::FileSystem"),
				})
				if err != nil {
					return diag.WrapError(err)
				}
				var resourceJson map[string]interface{}
				if err := json.Unmarshal([]byte(*r.ResourceDescription.Properties), &resourceJson); err != nil {
					return diag.WrapError(err)
				}
				resourceJson["Arn"] = *it.Identifier
				resourceJson["account_id"] = c.AccountID
        resourceJson["region"] = c.Region
				res <- resourceJson
				return nil
			})
		}
		if err := errGroup.Wait(); err != nil {
			return diag.WrapError(err)
		}
		// res <- batchResults
		if aws.ToString(listResources.NextToken) == "" {
			break
		}
		config.NextToken = listResources.NextToken
	}

	return nil
}
